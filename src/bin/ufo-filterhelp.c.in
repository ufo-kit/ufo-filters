/*
 * Copyright (C) 2015 Karlsruhe Institute of Technology
 *
 * This file is part of ufo-filters.
 *
 * ufo-filters is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * ufo-filters is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with runjson.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <ufo/ufo.h>

const gchar *filter_names = "@FILTER_LIST@";

int
main(int argc, char* argv[])
{
    GOptionContext *context;
    GError *error = NULL;
    UfoPluginManager *pm;

    static gboolean filters = FALSE;

    static GOptionEntry entries[] = {
        { "list-filters", 'l', 0, G_OPTION_ARG_NONE, &filters, "list all available filters", NULL },
        { NULL }
    };

#if !(GLIB_CHECK_VERSION (2, 36, 0))
    g_type_init ();
#endif

    context = g_option_context_new ("TASK [TASK ...]");
    g_option_context_set_summary (context, "Provides information about installed UFO filters and tasks");
    g_option_context_add_main_entries (context, entries, NULL);

    if (!g_option_context_parse (context, &argc, &argv, &error)) {
        g_print ("Error parsing options: %s\n", error->message);
        return 1;
    }

    if (filters) {
        gchar **names = g_strsplit (filter_names, ";", -1);
        if (!names) {
            g_print ("No available filters could be found.\n");
        }
        else {
            g_print ("The following filters and tasks are available:\n");
            guint i = 0;
            while (names[i]) {
                g_print ("%s\n", names[i]);
                i++;
            }
        }
        g_strfreev (names);
        return 0;
    }

    if (argc == 1) {
        g_print ("%s", g_option_context_get_help (context, TRUE, NULL));
        return 0;
    }

    pm = ufo_plugin_manager_new ();

    for (gint i = 1; i < argc; i++) {
        UfoTaskNode *node = ufo_plugin_manager_get_task (pm, argv[i], &error);

        if (node) {
            GObjectClass *node_class = G_OBJECT_GET_CLASS (node);

            guint num_props = 0;
            GParamSpec **pspecs = g_object_class_list_properties (node_class, &num_props);

            if (pspecs) {
                g_print ("#\n");
                g_print ("# Filter '%s' exposes the following properties\n", argv[i]);
                g_print ("#\n");
                for (guint j = 0; j < num_props; j++) {
                    if (0 == g_strcmp0 (pspecs[j]->name, "num-processed"))
                        continue;
                    g_print ("-- %s\n", pspecs[j]->name);
                    g_print ("Type: %s\n", g_type_name (pspecs[j]->value_type));
                    g_print ("Info: %s\n", g_param_spec_get_nick (pspecs[j]));
                    g_print ("Description: %s\n", g_param_spec_get_blurb (pspecs[j]));
                    g_print ("\n");
                }
            }

            g_free (pspecs);
            g_object_unref (node);
        }
        else {
            g_print ("@\n");
            if (error) {
                g_print ("@ Warning: Could not find '%s' filter: %s\n", argv[i], error->message);
                g_clear_error (&error);
                error = NULL;
            }
            else {
                g_print ("@ Warning: Could not find '%s' filter: An unknown error occured", argv[i]);
            }
            g_print ("@\n");
        }
    }

    g_object_unref (pm);
    g_option_context_free (context);
    return 0;
}
